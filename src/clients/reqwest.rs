use crate::{client::Client, enums::RequestMethod, errors::ClientError};
use reqwest::{
    header::{HeaderMap, HeaderName, HeaderValue},
    Method,
};
use serde_json::Value;
use std::str::FromStr;
use url::Url;

/// When implemented and passed to a [ReqwestClient], provides the ability to
/// modify all requests generated by the client before being sent out on the
/// wire.
///
/// # Example
/// ```
/// use reqwest::header::HeaderValue;
/// use reqwest::blocking::Request;
/// use rustify::clients::reqwest::MiddleWare;
///
/// struct TestMiddleWare {
///     value: String,
/// }
///
/// impl MiddleWare for TestMiddleWare {
///     fn handle(&self, mut r: Request) -> Request {
///         r.headers_mut().append(
///             "Test-Header",
///             HeaderValue::from_str(self.value.as_str()).unwrap(),
///         );
///         r
///    }
/// }
/// ```
pub trait MiddleWare {
    fn handle(&self, r: reqwest::blocking::Request) -> reqwest::blocking::Request;
}

/// A dummy implementation of [MiddleWare] for use in creating clients that do
/// not need to utilize any middleware features.
struct DefaultMiddleWare {}
impl MiddleWare for DefaultMiddleWare {
    fn handle(&self, r: reqwest::blocking::Request) -> reqwest::blocking::Request {
        r
    }
}

/// A client based on the
/// [reqwest::blocking::Client][1] which can be used for executing
/// [Endpoints][crate::endpoint::Endpoint]. A backing instance of a
/// [reqwest::blocking::Client][1] is used to increase performance and save
/// certain characteristics across sessions. A base URL is required and is used
/// to qualify the full path of any [Endpoints][crate::endpoint::Endpoint] which
/// are executed by this client. An optional instance of an object implementing
/// [MiddleWare] can be passed to the client in order to operate on all requests
/// handled by this client before being sent out.
///
/// # Example
/// ```
/// use rustify::clients::reqwest::ReqwestClient;
/// use rustify::endpoint::Endpoint;
/// use rustify_derive::Endpoint;
/// use serde::Serialize;
///
/// #[derive(Debug, Endpoint, Serialize)]
/// #[endpoint(path = "my/endpoint")]
/// struct MyEndpoint {}
///
/// let client = ReqwestClient::default("http://myapi.com");
/// let endpoint = MyEndpoint {};
/// let result = endpoint.execute(&client);
/// ```
///
/// [1]: https://docs.rs/reqwest/latest/reqwest/blocking/struct.Client.html
pub struct ReqwestClient {
    pub http: reqwest::blocking::Client,
    pub base: String,
    pub middle: Box<dyn MiddleWare>,
}

impl ReqwestClient {
    /// Creates a new instance of [ReqwestClient] using the provided parameters
    pub fn new(base: &str, http: reqwest::blocking::Client, middle: Box<dyn MiddleWare>) -> Self {
        ReqwestClient {
            base: base.to_string(),
            http,
            middle,
        }
    }

    /// Creates a new instance of [ReqwestClient] with a default instance of
    /// [reqwest::blocking::Client][1] and a no-op implementation of
    /// [MiddleWare].
    ///
    /// [1]: https://docs.rs/reqwest/latest/reqwest/blocking/struct.Client.html
    pub fn default(base: &str) -> Self {
        ReqwestClient {
            base: base.to_string(),
            http: reqwest::blocking::Client::default(),
            middle: Box::new(DefaultMiddleWare {}),
        }
    }

    /// Creates a new instance of [ReqwestClient] with a default instance of
    /// [reqwest::blocking::Client][1] and the provided [MiddleWare].
    ///
    /// [1]: https://docs.rs/reqwest/latest/reqwest/blocking/struct.Client.html
    pub fn with_middleware(base: &str, middle: Box<dyn MiddleWare>) -> ReqwestClient {
        ReqwestClient {
            base: base.to_string(),
            http: reqwest::blocking::Client::default(),
            middle,
        }
    }

    fn build_request(
        &self,
        method: &RequestMethod,
        url: &Url,
        query: &[(String, Value)],
        headers: &[(String, String)],
        data: Vec<u8>,
    ) -> Result<reqwest::blocking::Request, ClientError> {
        let builder = match method {
            RequestMethod::DELETE => match data.is_empty() {
                false => self.http.delete(url.as_ref()).body(data),
                true => self.http.delete(url.as_ref()),
            },
            RequestMethod::GET => self.http.get(url.as_ref()),
            RequestMethod::HEAD => match data.is_empty() {
                false => self.http.head(url.as_ref()).body(data),
                true => self.http.head(url.as_ref()),
            },
            RequestMethod::LIST => match data.is_empty() {
                false => self
                    .http
                    .request(Method::from_str("LIST").unwrap(), url.as_ref())
                    .body(data),
                true => self
                    .http
                    .request(Method::from_str("LIST").unwrap(), url.as_ref()),
            },
            RequestMethod::POST => match data.is_empty() {
                false => self.http.post(url.as_ref()).body(data),
                true => self.http.post(url.as_ref()),
            },
        };

        let mut map = HeaderMap::new();
        headers.iter().for_each(|h| {
            map.insert(
                HeaderName::from_str(h.0.as_str()).unwrap(),
                HeaderValue::from_str(h.1.as_str()).unwrap(),
            );
        });

        let req = builder.query(query).headers(map).build().map_err(|e| {
            ClientError::RequestBuildError {
                source: Box::new(e),
                url: url.to_string(),
                method: method.clone(),
            }
        })?;
        Ok(self.middle.handle(req))
    }
}

impl Client for ReqwestClient {
    fn base(&self) -> &str {
        self.base.as_str()
    }

    fn send(&self, req: crate::client::Request) -> Result<crate::client::Response, ClientError> {
        let request =
            self.build_request(&req.method, &req.url, &req.query, &req.headers, req.body)?;

        let err_url = req.url;
        let err_method = req.method;
        let response = self
            .http
            .execute(request)
            .map_err(|e| ClientError::RequestError {
                source: Box::new(e),
                url: err_url.to_string(),
                method: err_method,
            })?;

        let url = response.url().clone();
        let status_code = response.status().as_u16();
        let body = response
            .bytes()
            .map_err(|e| ClientError::ResponseError {
                source: Box::new(e),
            })?
            .to_vec();
        Ok(crate::client::Response {
            url,
            code: status_code,
            body,
        })
    }
}
