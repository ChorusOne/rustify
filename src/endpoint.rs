use crate::{
    client::Client,
    enums::{RequestMethod, RequestType, ResponseType},
    errors::ClientError,
};
use async_trait::async_trait;
use bytes::Bytes;
use http::Request as HttpRequest;
use http::Response as HttpResponse;
use http::Uri;
use serde::{de::DeserializeOwned, Serialize};
use serde_json::Value;
use url::Url;

/// Represents a generic wrapper that can be applied to [Endpoint] results.
///
/// Some APIs use a generic wrapper when returning responses that contains
/// information about the response and the actual response data in a subfield.
/// This trait allows implementing a generic wrapper which can be used with
/// [Endpoint::exec_wrap] to automatically wrap the [Endpoint::Result] in the
/// wrapper. The only requirement is that the [Wrapper::Value] must enclose
/// the [Endpoint::Result].
pub trait Wrapper: DeserializeOwned {
    type Value;
}

/// Represents a remote HTTP endpoint which can be executed using a
/// [crate::client::Client].
///
/// This trait can be implemented directly, however, users should prefer using
/// the provided `rustify_derive` macro for generating implementations. An
/// Endpoint consists of:
///   * An `action` which is combined with the base URL of a Client to form a
///     fully qualified URL.
///   * A `method` of type [RequestType] which determines the HTTP method used
///     when a Client executes this endpoint.
///   * A `ResponseType` type which determines the type of response this
///     Endpoint will return when executed.
///
/// Presently, this trait only supports sending and receiving data using JSON.
/// The struct implementing this trait must also implement [serde::Serialize].
/// The fields of the struct act as a representation of data that will be
/// serialized and sent to the remote server. Fields that should be excluded
/// from this behavior can be tagged with the `#[serde(skip)]` attribute. The
/// Endpoint will take the raw response body from the remote server and attempt
/// to deserialize it into the given `ResponseType` which must implement
/// [serde::Deserialize]. This deserialized value is then returned after
/// execution completes.
///
/// Implementations can override the default [transform][Endpoint::transform] in
/// order to modify the raw response content from the remote server before
/// returning it. This is often useful when the remote API wraps all responses
/// in a common format and the desire is to remove the wrapper before returning
/// the deserialized response. It can also be used to check for any errors
/// generated by the API and escalate them accordingly.
///
/// # Example
/// ```
/// use rustify::clients::reqwest::ReqwestClient;
/// use rustify::endpoint::Endpoint;
/// use rustify_derive::Endpoint;
/// use serde::Serialize;
///
/// #[derive(Debug, Endpoint, Serialize)]
/// #[endpoint(path = "my/endpoint")]
/// struct MyEndpoint {}
///
/// // Configure a client with a base URL of http://myapi.com
/// let client = ReqwestClient::default("http://myapi.com");
///     
/// // Construct a new instance of our Endpoint
/// let endpoint = MyEndpoint {};
///
/// // Execute our Endpoint using the client
/// // This sends a GET request to http://myapi.com/my/endpoint
/// // It assumes an empty response
/// let result = endpoint.exec(&client);
/// ```
#[async_trait]
pub trait Endpoint: Send + Sync + Serialize + Sized {
    /// The type that the raw response from executing this endpoint will
    /// automatically be deserialized to. This type must implement
    /// [serde::Deserialize].
    type Result: DeserializeOwned;

    /// The content type of the request body
    const REQUEST_BODY_TYPE: RequestType;

    /// The content type of the response body
    const RESPONSE_BODY_TYPE: ResponseType;

    /// The relative URL path that represents the location of this Endpoint.
    /// This is combined with the base URL from a
    /// [Client][crate::client::Client] instance to create the fully qualified
    /// URL.
    fn path(&self) -> String;

    /// The HTTP method to be used when executing this Endpoint.
    fn method(&self) -> RequestMethod;

    /// Optional query parameters to add to the request
    fn query(&self) -> Vec<(String, Value)> {
        Vec::new()
    }

    /// Optional raw request data that will be sent instead of serializing the
    /// struct.
    fn data(&self) -> Option<&[u8]> {
        None
    }

    /// Executes the Endpoint using the given [Client] and returns the
    /// deserialized response as defined by [Endpoint::Result].
    async fn exec<C: Client>(&self, client: &C) -> Result<Option<Self::Result>, ClientError> {
        log::info!("Executing endpoint");

        let req = build_request(
            client.base(),
            self.path().as_str(),
            self.method(),
            self.query(),
            build_body(self, Self::REQUEST_BODY_TYPE, self.data())?,
        )?;
        let resp = client.execute(req).await?;
        parse(self, resp.body())
    }

    /// Executes the Endpoint using the given [Client] and [MiddleWare],
    /// returning the deserialized response as defined by [Endpoint::Result].
    async fn exec_mut<C: Client, M: MiddleWare>(
        &self,
        client: &C,
        middle: &M,
    ) -> Result<Option<Self::Result>, ClientError> {
        log::info!("Executing endpoint");

        let mut req = build_request(
            client.base(),
            self.path().as_str(),
            self.method(),
            self.query(),
            build_body(self, Self::REQUEST_BODY_TYPE, self.data())?,
        )?;
        middle.request(self, &mut req)?;

        let mut resp = client.execute(req).await?;
        middle.response(self, &mut resp)?;
        parse(self, resp.body())
    }

    /// Executes the Endpoint using the given [Client] and returns the
    /// deserialized [Endpoint::Result] wrapped in a [Wrapper].
    async fn exec_wrap<C, W>(&self, client: &C) -> Result<Option<W>, ClientError>
    where
        C: Client,
        W: Wrapper<Value = Self::Result>,
    {
        log::info!("Executing endpoint");

        let req = build_request(
            client.base(),
            self.path().as_str(),
            self.method(),
            self.query(),
            build_body(self, Self::REQUEST_BODY_TYPE, self.data())?,
        )?;
        let resp = client.execute(req).await?;
        parse(self, resp.body())
    }

    /// Executes the Endpoint using the given [Client] and [MiddleWare],
    /// returning the deserialized [Endpoint::Result] wrapped in a [Wrapper].
    async fn exec_wrap_mut<C, M, W>(&self, client: &C, middle: &M) -> Result<Option<W>, ClientError>
    where
        C: Client,
        M: MiddleWare,
        W: Wrapper<Value = Self::Result>,
    {
        log::info!("Executing endpoint");

        let mut req = build_request(
            client.base(),
            self.path().as_str(),
            self.method(),
            self.query(),
            build_body(self, Self::REQUEST_BODY_TYPE, self.data())?,
        )?;
        middle.request(self, &mut req)?;

        let mut resp = client.execute(req).await?;
        middle.response(self, &mut resp)?;
        parse(self, resp.body())
    }

    /// Executes the Endpoint using the given [Client], returning the raw
    /// response as a byte array.
    async fn exec_raw<C: Client>(&self, client: &C) -> Result<Bytes, ClientError> {
        log::info!("Executing endpoint");

        let req = build_request(
            client.base(),
            self.path().as_str(),
            self.method(),
            self.query(),
            build_body(self, Self::REQUEST_BODY_TYPE, self.data())?,
        )?;

        let resp = client.execute(req).await?;
        Ok(resp.body().clone())
    }

    /// Executes the Endpoint using the given [Client] and [MiddleWare],
    /// returning the raw response as a byte array.
    async fn exec_raw_mut<C: Client, M: MiddleWare>(
        &self,
        client: &C,
        middle: &M,
    ) -> Result<Bytes, ClientError> {
        log::info!("Executing endpoint");

        let mut req = build_request(
            client.base(),
            self.path().as_str(),
            self.method(),
            self.query(),
            build_body(self, Self::REQUEST_BODY_TYPE, self.data())?,
        )?;
        middle.request(self, &mut req)?;

        let mut resp = client.execute(req).await?;
        middle.response(self, &mut resp)?;
        Ok(resp.body().clone())
    }
}
pub trait MiddleWare: Sync + Send {
    fn request<E: Endpoint>(
        &self,
        endpoint: &E,
        req: &mut HttpRequest<Vec<u8>>,
    ) -> Result<(), ClientError>;
    fn response<E: Endpoint>(
        &self,
        endpoint: &E,
        resp: &mut HttpResponse<Bytes>,
    ) -> Result<(), ClientError>;
}

/// Builds a [Request] using the given [Endpoint] and base URL
/* fn build_request<E: Endpoint>(
    endpoint: &E,
    base: &str,
    data: Option<&[u8]>,
) -> Result<Request, ClientError> {
    let url = build_url(endpoint, base)?;
    let method = endpoint.method();
    let query = endpoint.query();
    let headers = Vec::new();
    let body = match data {
        Some(d) => d.to_vec(),
        None => match E::REQUEST_BODY_TYPE {
            RequestType::JSON => {
                let parse_data =
                    serde_json::to_string(endpoint).map_err(|e| ClientError::DataParseError {
                        source: Box::new(e),
                    })?;
                match parse_data.as_str() {
                    "null" => "".to_string(),
                    "{}" => "".to_string(),
                    _ => parse_data,
                }
                .into_bytes()
            }
        },
    };

    Ok(Request {
        url,
        method,
        query,
        headers,
        body,
    })
} */

pub fn build_body<S: Serialize>(
    object: &S,
    ty: RequestType,
    data: Option<&[u8]>,
) -> Result<Vec<u8>, ClientError> {
    match data {
        Some(d) => Ok(d.to_vec()),
        None => match ty {
            RequestType::JSON => {
                let parse_data =
                    serde_json::to_string(object).map_err(|e| ClientError::DataParseError {
                        source: Box::new(e),
                    })?;
                Ok(match parse_data.as_str() {
                    "null" => "".to_string(),
                    "{}" => "".to_string(),
                    _ => parse_data,
                }
                .into_bytes())
            }
        },
    }
}

/// Builds a [Request] using the given [Endpoint] and base URL
pub fn build_request(
    base: &str,
    path: &str,
    method: RequestMethod,
    query: Vec<(String, Value)>,
    data: Vec<u8>,
) -> Result<HttpRequest<Vec<u8>>, ClientError> {
    let uri = build_url(base, path, query)?;

    let method_err = method.clone();
    let uri_err = uri.to_string();
    HttpRequest::builder()
        .uri(uri)
        .method(method)
        .body(data)
        .map_err(|e| ClientError::RequestBuildError {
            source: Box::new(e),
            method: method_err,
            url: uri_err,
        })
}

/// Combines the given base URL with the relative URL path from this
/// Endpoint to create a fully qualified URL.
fn build_url(base: &str, path: &str, query: Vec<(String, Value)>) -> Result<Uri, ClientError> {
    log::info!(
        "Building endpoint url from {} base URL and {} action",
        base,
        path,
    );

    let mut url = Url::parse(base).map_err(|e| ClientError::UrlParseError {
        url: base.to_string(),
        source: e,
    })?;
    url.path_segments_mut().unwrap().extend(path.split('/'));

    {
        let mut pairs = url.query_pairs_mut();
        let serializer = serde_urlencoded::Serializer::new(&mut pairs);
        query
            .serialize(serializer)
            .map_err(|e| ClientError::UrlQueryParseError {
                source: Box::new(e),
            })?;
    }

    Ok(url.to_string().parse::<Uri>().unwrap())
}

/// Parses a response body into the [Endpoint::Result], choosing a deserializer
/// based on [Endpoint::RESPONSE_BODY_TYPE].
fn parse<E: Endpoint, T: DeserializeOwned>(_: &E, body: &[u8]) -> Result<Option<T>, ClientError> {
    if body.is_empty() {
        return Ok(None);
    }

    match E::RESPONSE_BODY_TYPE {
        ResponseType::JSON => {
            serde_json::from_slice(body).map_err(|e| ClientError::ResponseParseError {
                source: Box::new(e),
                content: String::from_utf8(body.to_vec()).ok(),
            })
        }
    }
}
